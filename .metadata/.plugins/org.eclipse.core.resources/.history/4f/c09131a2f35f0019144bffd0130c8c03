package com.kuozhan

/**
参考:http://www.runoob.com/kotlin/kotlin-extensions.html
扩展函数：

扩展属性：扩展属性只能是val,所以没有setter方法。没有后端变量field，所以不可以被初始化



 */

//1.扩展函数基础------------------------------------------------------------------
class Original {
	fun originalFun() {
		println("originalFun ")
	}
}

//Original 的扩展函数
fun Original.ExFun() {
	originalFun()
	println("ExFun");
}

//扩展函数和成员函数同名时，优先执行成员函数
fun Original.originalFun() {
	println("扩展的originalFun")
}

fun MutableList<Int>.swap(index1: Int, index2: Int) {
	val temp = this[index1]
	this[index1] = this[index2]
	this[index2] = temp
}

//2.扩展属性------------------------------------------------------------------
val Original.name: String
	get() = "this is expand name"

//3.扩展函数是静态解析的------------------------------------------------------------------
open class Fu {
	open fun run() {
		println("fu run");
	}
}

class Zi : Fu() {
	override fun run() {
		println("zi run");
	}
}

fun Fu.foo() {
	println("fu foo")
}

fun Zi.foo() {
	println("zi foo")
}

fun testFoo(fu: Fu) {//测试扩展函数,静态,"fu foo"
	fu.foo()
}

fun testRun(fu: Fu) {//测试多态，动态
	fu.run()
}

//4.扩展空对象,如果不加“？”扩展函数会被Any的成员函数覆盖-----------------------------
fun Any?.toString(): String {
	if (this == null) {
		return "null null null  "
	}
	return toString()
}

//5.伴生对象------------------------------------------------------------------
class MyClass {
	companion object {}
}

fun MyClass.Companion.foo() {
	println("伴随对象的扩展函数")
}

val MyClass.Companion.num: Int
	get() = 10

//6.扩展函数可以在其他类里，作为其他类的成员函数------------------------------------------------------------------
//扩展接受者
class A {
	fun aFun() {
		println("aFun")
	}

	fun call() {
		println("a call");
	}
}

//分发接受者
class B {
	fun bFun() {
		println("bFun")
	}

	fun call() {
		println("b call");
	}

	fun A.expandFun() {
		aFun()
		bFun()

		call()//a call;假如某一函数在分发接受者和扩展接受者中均存在，以扩展接受者优先
		this@B.call()//b call
	}

	fun foo(a: A) {
		a.expandFun()
	}
}

fun main(args: Array<String>) {
	println("1.扩展函数基础--------------------------")
	val original: Original = Original()
	original.ExFun()
	original.originalFun()//扩展函数和成员函数同名时，优先执行成员函数

	val list = mutableListOf(1, 2, 3)
	println("original list:${list}");
	list.swap(0, 2)
	println("swaped list: ${list}");

	println("1.扩展属性--------------------------")
	println("original.name = ${original.name}")

	println("3.扩展函数是静态解析的------------------------")
	testFoo(Zi())//fu foo
	testRun(Zi())//多态是动态的

	println("4.扩展空对象--------------------------")
	val t = null
	println(t.toString());

	println("5.伴生对象--------------------------")
	println("MyClass.num = ${MyClass.num}");
	MyClass.foo()

	println("6.扩展函数作为成员变量--------------------------")
	val b: B = B()
	b.foo(A())

}















