package com.jiage.spinlock;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

/**
 * 参考：https://blog.csdn.net/qq_34337272/article/details/81252853
 * 
 * 公平锁：先排队的先拿到锁
 * 
 * 思路：每个线程都持有一个排号，号码依次增大；持有小号的线程释放锁后，锁传递给持有大号的线程
 *
 */
public class TicketLock implements MyLock {
	private ThreadLocal<Integer> threadTicketNum = new ThreadLocal<Integer>();
	private AtomicReference<Thread> atomicReference = new AtomicReference<Thread>();
	private int ticketNum = 0;
	private AtomicInteger currentNum = new AtomicInteger(1);
	private int count = 0;

	@Override
	public void lock() {
		Thread current = Thread.currentThread();
		if (atomicReference.get() == current) {
			count++;
			return;
		}
		threadTicketNum.set(ticketNum++);
		while (currentNum.get() != threadTicketNum.get()) {

		}
		atomicReference.compareAndSet(null, current);
	}

	@Override
	public void unLock() {
		Thread current = Thread.currentThread();
		if (atomicReference.get() == current) {
			if (count > 0) {
				count--;
			} else {
				atomicReference.compareAndSet(current, null);
				int value = currentNum.get();
				currentNum.compareAndSet(value, value + 1);
			}
		}
	}
}
