package com.jiage.spinlock;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

/**
 * 参考：https://blog.csdn.net/qq_34337272/article/details/81252853
 * 
 * 公平锁：先排队的先拿到锁
 * 
 * 思路：每个线程都持有一个流水号，号码依次增大；持有小号的线程释放锁后，锁传递给持有大号的线程
 * 
 * 缺点：不同线程读取currentNum，每次读写操作都要进行主内存和工作内存的同步，会导致繁重的总线和内存流量
 *
 */
public class TicketLock implements MyLock {
	private ThreadLocal<Integer> threadTicketNum = new ThreadLocal<Integer>();// 每个线程持有的号码
	private AtomicReference<Thread> atomicReference = new AtomicReference<Thread>();// 存储当前线程
	private AtomicInteger ticketNum = new AtomicInteger(0);// 每个线程的排队号
	private AtomicInteger currentNum = new AtomicInteger(1);// 当前正执行的号.主内存自旋
	private int count = 0;// 可重入锁使用

	@Override
	public void lock() {
		Thread current = Thread.currentThread();
		if (atomicReference.get() == current && currentNum.get() == threadTicketNum.get()) {
			count++;
			return;
		}
		threadTicketNum.set(ticketNum.incrementAndGet());// 给当前线程设置排队号码
		while (currentNum.get() != threadTicketNum.get()) {

		}
		atomicReference.compareAndSet(null, current);
	}

	@Override
	public void unLock() {
		Thread current = Thread.currentThread();
		if (atomicReference.get() == current) {
			if (count > 0) {
				count--;
			} else {
				atomicReference.compareAndSet(current, null);
				int value = threadTicketNum.get();
				currentNum.compareAndSet(value, value + 1);
			}
		}
	}
}
